package main

import (
	"encoding/json"
	"log"
	"net/http"
	"time"

	"edgeforge/backend/internal/metrics"
	"edgeforge/backend/internal/middleware"
)

type RequestBody struct {
	Route   string         `json:"route"`
	Payload map[string]any `json:"payload"`
}

type RequestResponse struct {
	RequestID string `json:"requestId"`
	RoutedTo  string `json:"routedTo"`
	Status    string `json:"status"`
}

func writeJSON(w http.ResponseWriter, statusCode int, v any) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	_ = json.NewEncoder(w).Encode(v)
}

func main() {
	m := metrics.New()
	mux := http.NewServeMux()

	// Health endpoint
	mux.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) {
		writeJSON(w, http.StatusOK, map[string]any{
			"status":  "ok",
			"service": "edgeforge-gateway",
		})
	})

	// Status endpoint
	mux.HandleFunc("/api/v1/status", func(w http.ResponseWriter, r *http.Request) {
		writeJSON(w, http.StatusOK, m.Snapshot())
	})

	// Request endpoint
	mux.HandleFunc("/api/v1/request", func(w http.ResponseWriter, r *http.Request) {
		if r.Method != http.MethodPost {
			writeJSON(w, http.StatusMethodNotAllowed, map[string]any{"error": "method_not_allowed"})
			return
		}

		var body RequestBody
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			m.IncErrors()
			writeJSON(w, http.StatusBadRequest, map[string]any{"error": "invalid_json"})
			return
		}

		// Tracking request count
		m.IncRequests()

		time.Sleep(80 * time.Millisecond)

		// Using requestId generated by middleware
		reqID := middleware.GetRequestID(r)

		// Simulating routing based on route
		routedTo := "mock-generic-service"
		if body.Route == "/orders" {
			routedTo = "mock-orders-service"
		} else if body.Route == "/analytics" {
			routedTo = "mock-analytics-service"
		}

		writeJSON(w, http.StatusOK, RequestResponse{
			RequestID: reqID,
			RoutedTo:  routedTo,
			Status:    "success",
		})
	})

	handler := middleware.WithRequestIDAndLogging(mux)

	log.Println("EdgeForge backend running on :8080")
	log.Fatal(http.ListenAndServe(":8080", handler))
}
